"""MDH@07FEB2017:- adding getClientNames(separator) for returning the names of the clientsMDH@05JUN2016:- adapted from tcpserver  but without the shit we had in there from module communicator  a tcp server as we may need for certain applications  extends the dict containing its properties"""import sysimport timeimport threadingimport socketimport cStringIO# MDH@28OCT2014: moving DEBUG and other stuff to the outer levelDEBUG=False# MDH@02FEB2017: we want to be able to close any client socket if we haven't received any data for 30 seconds#                I suppose 3 successive fails will suffice, send every 15 secondsdef set_keepalive_linux(sock, after_idle_sec=1, interval_sec=15, max_fails=2):	"""Set TCP keepalive on an open socket.	It activates after 1 second (after_idle_sec) of idleness,	then sends a keepalive ping once every 15 seconds (interval_sec),	and closes the connection after 2 failed ping (max_fails), or 30 seconds	"""	sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)	sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, after_idle_sec)	sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, interval_sec)	sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, max_fails)# changed the name from tcpserver to TcpServerclass TcpServer(dict):	infoHandler=None # MDH@08JUN2016: when run inside some other code, with its own output handling, we want to be able to change that	def inform(self,_toinform):		if callable(self['infohandler']):			self['infohandler'](_toinform)		else:			print _toinform	# the file to write the output text to	def getName(self):		if 'name' in self:			return self['name']		return None	def output(self,_tooutput,_force=0):		if isinstance(_tooutput,str):			global DEBUG			if _force or DEBUG:				name=self.getName()				if name is not None:					self.inform("("+name+") "+_tooutput)				else:					self.inform(_tooutput)	def outputerror(self,_error):		if isinstance(_error,str):			self.output("ERROR: "+_error,1)	def outputwarning(self,_warning):		if isinstance(_warning,str):			self.output("WARNING: "+_warning,1)	class Client(threading.Thread):		# MDH@04JUL2013: main (private) method to get something sent immediately		def sendnow(self,_tosendnow):			result=None			if self.client and isinstance(_tosendnow,str):				try:					self.client.sendall(_tosendnow+"\r\n")					# reset the left to end of push interval counter					# NOTE self.pushInterval might be zero to start with though					self.leftToEndOfPushInterval=self.pushInterval				except Exception,ex:					result=ex			return result		# MDH@04JUL2013: if in pull mode we're accumulating what is to be sent over		def sendPushables(self):			if self.pushables and self.client:				result=0				while len(self.pushables)>0:					result+=1					# the first time we fail to send something, stop sending					if self.sendnow(self.pushables.pop()):						return -result			return 0		def send(self,_tosend):			# if not a string no go			if not isinstance(_tosend,str):				return 0			# in pull mode we accumulate until we receive a pull request			if self.pushables:				# pop() will pop() from the end, so we need to use it as a queue				self.pushables.insert(0,_tosend)				return 0			# in push mode so send immediately, returning the error code senderror returns			return self.sendnow(_tosend)		# MDH@04JUL2013: we're defining push and pull methods		def initialize(self):			self.receivedIO=cStringIO.StringIO()			self.name=None # MDH@24JAN2017: perhaps better doing it this way!!!			self.endOfMessage=False			self.pingMessage=None			self.pullMessage='pull'			self.pushMessage='push'			# MDH@27AUG2013: the bye message indicates that a client is going to stop sending data over (so can be removed!!!)			self.byeMessage='bye'			# MDH@28OCT2014: how about processing hi messages, and acknowledging (or not)			self.hiMessagePrefix='hi'			self.acking=True			self.running=False			# MDH@04JUL2013: keep track when data was last received			self.dataReceived=None			# the mode we're in (either push or pull mode)			# we keep a list of pushables when in pull mode			self.pushables=None			# by default NO push interval			self.pushInterval=0			self.leftToEndOfPushInterval=0		def startPushing(self,_pushInterval):			# needs a server, so BEFORE the server is killed we should call this thing here			if isinstance(_pushInterval,int):				if _pushInterval>0: # should be checking for push timeouts					if self.pushInterval<=0 or self.server.startTicking():						self.pushInterval=_pushInterval				else: # should NOT be checking for push timeouts					if self.pushInterval>0: # R pushing						self.server.stopTicking()					self.pushInterval=_pushInterval		def checkForPushTimeout(self):			if self.pushInterval:				self.leftToEndOfPushInterval-=1				# keep a little slack for sending				if self.leftToEndOfPushInterval<5: # only 5 seconds left to push something over					# if we succeed in sending something start over					# TODO this is a bit dangerous as we might be sending					#      something over every second but that's OK for now					self.sendnow("pong")		# we run the code in run taking care of reading the clients data		def processMessage(self):			## print "A"			received=self.receivedIO.getvalue().rstrip()			if len(received)==0:				return			if received[0]=='>':				self.server.output("Received from client: '"+received+"' not to be logged.")				return			self.server.output("Processing "+received+".")			# MDH@27AUG2013: it could be a bye as well			# MDH@14JAN2017: only accept bye if there was a previous hi message which we can tell by checking self.name (see below)			if received==self.byeMessage and self.name is not None:				# ascertain to stop receiving, will None the self.server and be removed in due course				self.running=False				return			self.server.output("Received from client: '"+received+"'.") # requires DEBUG to be True			try:				# check for hi, ping, pull or push				# MDH@28OCT2014: process hi messages as well				# MDH@14JAN2017: let the user identify himself in the hi message (the second word)!!!				receivedWords=received.split()				if receivedWords[0]==self.hiMessagePrefix:					self.name="" # MDH@14JAN2017: anonymous user initially...					# the second word is either noack or the name of the client (therefore NOT noack in any situation!!)					if len(receivedWords)>1 and receivedWords[1]=='noack':						self.acking=False						self.server.output("Hi noack message received!")						# if there's a word in the middle that is remembered as the name						if len(receivedWords)>2:							self.name=receivedWords[-1]							self.server.output("Client name '"+self.name+"'.")					else:						self.server.output("Hi message received!")						if len(receivedWords)>1:							self.name=receivedWords[-1]							self.server.output("Client name '"+self.name+"'.")					received=None					if len(self.name)==0:						self.server.output("No client name in hi message!");				elif received==self.pingMessage:					received=None					# MDH@28OCT2014: only when we're supposed to acknowledge stuff					if self.acking:						# always acknowledged immediately (even when in pull mode)						errorcode=self.sendnow("ack "+self.pingMessage)						if errorcode:							self.server.outputError("Failed to acknowledge ping message (error code: "+str(errorcode)+")!")						else:							self.server.output("Ping message acknowledged!",1)				elif received==self.pushMessage: # explicit request to push (not with a push interval)					self.sendPushables()					# nothing to push over anymore (meaning we're considered to be in push mode (see send))					self.pushables=None				elif received==self.pullMessage:					self.sendPushables()					# we're supposed to be in pull mode, and we start again with an empty list of pushables					self.pushables=[]					# acknowledge the pull explicitly (so even if nothing was sent)					if self.acking:						errorcode=self.sendnow("ack "+self.pullMessage)						if errorcode:							self.server.outputerror("Failed to acknowledge (=end) pull request (error code: "+str(errorcode)+").")				elif len(received)>=4 and received[:4]=='ack ':					received=None				elif len(received)>4 and received[:5]=='push ':					# ought to be a push request with a deadline					self.startPushing(int(received[5:]))				# if received is still defined, communicate it to whomever is listening				if isinstance(received,str):					if self.server and self.server.processor: # pass along as tuple with the client as first element!!!						self.server.processor((self,received))					else:						print "ERROR: Failed to pass '"+received+"' from "+str(self)+" along."				## self.server.output(("Received at %s: '"+received+"'.")%time.strftime("%H:%M:%S"),1)				## print "J"			except Exception,ex:				if isinstance(received,str):					if self.server:						self.server.outputerror("'"+str(ex)+"' in processing '"+received+"'.")					else:						print "ERROR: '"+str(ex)+" processing '"+received+"'."		def run(self):			# most convenient to initialize the flag to True here			self.running=True			while self.running:				try:					data=self.client.recv(512)					if data:						if len(data):							# remember the time data was received							self.dataReceived=time.time()							for c in data:								if self.endOfMessage:									if c=='\n':										self.endOfMessage=False										self.processMessage()										self.receivedIO=cStringIO.StringIO()								else:									self.receivedIO.write(c)									if c=='\r':										self.endOfMessage=True				except socket.error,e:					pass #####print "'"+str(e)+"' receiving/processing socket data."				time.sleep(0.005)			# MDH@07JUL2013: stop pushing BEFORE removing the server BECAUSE if we don't pushing will continue to be checked!!!			if self.pushInterval>0:				self.startPushing(0)			self.server.output("TCP client stopped!",1)			srvr=self.server			self.server=None			srvr.cleanup()			# dispose of the client neatly			### self.client.shutdown(1)			self.client.close()			print "TCP client closed."		def stop(self):			# can we do the following?????			# if we remove the reference to the client the reading will stop by itself			self.running=False		# constructor		def __init__(self,_client,_server):			threading.Thread.__init__(self)			self.name=None # user may identify itself in a hi message...			# MDH@04JUL2013: initialize the member variables			self.initialize()			self.server=_server			# I think this is required			# obtain the 'ping' message we need to acknowledge (if not defined won't be acknowledged of course)			if self.server:				# NOT to register the client without a server!!!!				self.client=_client				if self.server.has_key('pingmsg'):					self.pingMessage=self.server['pingmsg']				# if we have a client (can we check the type?) we start running			if self.client: # we have a server now as well!!!!				# we don't want blocking when we are reading				self.client.setblocking(0)				set_keepalive_linux(self.client) # MDH@02FEB2017: assuming self.client is the actual socket, let's make it close if keeping alive fails!!!				# NOTE did try to call Thread.start() and even threading.Thread.start() but that wouldn't work so perhaps calling super will!!!				super(TcpServer.Client,self).start()				# caller can test for isAlive!!!!				# # if we failed to go live kill the reference to the client				# # if not Thread.isAlive():				# # 	self.client=None		# destructor		def __del__(self):			self.stop()	"""	# overriding the methods in communicator.Communicator to NOT print this information	def reportToCommunicate(self,_tocommunicate,_communicators):		if DEBUG:			print "Reporting to communicate "+str(_tocommunicate)+" by "+str(_communicators)+"."	def reportCommunicated(self,_communicated,_communicators):		if DEBUG:			print "Reporting communicated "+str(_communicated)+" by "+str(_communicators)+"."	"""	# let's separate the cleaning up, so we can call it when we want to kill a client	def cleanup(self,_host=None):		# MDH@08AUG2013: if we have another one already there get rid of that one		# MDH@08JUN2016: how about removing all clients originating from the same host????		#                we do this by collecting all combination that contain host, so we can remove them afterwards		clientsToRemove=[]		for tcpClient in self.tcpClients:			# MDH@01FEB2017: if server is no longer defined, which would be after stopping a client somehow, we should remove it as well!!!			if self.tcpClients[tcpClient].server is None or tcpClient[0]==_host:				clientsToRemove.append(tcpClient)		for clientToRemove in clientsToRemove:			self.tcpClients[clientToRemove].stop()			del self.tcpClients[clientToRemove]		""" replacing:		if self.tcpClients.has_key((host,port)):			# stop it immediately			self.tcpClients[(host,port)].stop()		"""	def processConnectionRequests(self):		while self.connectionRequestProcessingThread:			# MDH@29OCT2014: when closing the lot an exception should be thrown!!!			try:				# MDH@08AUG2013: splitting up addr in (host,port)				# accept request				client,(host,port)=self.serverSocket.accept()				self.output("Request to connect to "+str(host)+" on port "+str(port)+" accepted.",1)				# append the given client to the list of active clients				# using the add as unique name				newTcpClient=TcpServer.Client(client,self) #####,str(add))				if newTcpClient.isAlive():					self.cleanup(host) # separate method for doing the cleanup!!!					# no need to remove it, it will be replaced anyway					self.tcpClients[(host,port)]=newTcpClient					# MDH@09JUL2013: if successfully added inform the client that was added					if self.tcpClients.has_key((host,port)):						self.output("Client #"+str(len(self.tcpClients))+" added!",1)						if hasattr(self.clientAddedCallback,'__call__'):							self.clientAddedCallback(newTcpClient)					else:						self.output("ERROR: Failed to add client!",1)						# stop the new client						newTcpClient.stop() # replacing: newTcpClient.client=None						# NOTE add will typically be a tuple!						self.outputerror("Failed to register client "+str(host)+":"+str(port)+".")				else:					self.outputerror("Failed to start client "+str(host)+":"+str(port)+".")				# MDH 25JUN2013: sleep a while so other threads can do stuff to				time.sleep(0.25)			except Exception,ex:				self.outputerror("'"+str(ex)+"' processing a connection request!")		self.running=False	# MDH 26JUN2013: whatever the clients send over is to be passed to the sourcecommunicator	def start(self,_clients=128):		if not self.running:			try:				self.serverSocket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)				self.output("Server socket created!",1)				self.serverSocket.bind((self['bind'],self['port'])) # NOTE we have to pass a tuple!!				# MDH@08AUG2013: I'm glad I put 25 here, we could lower that a little bit				self.clients=_clients # MDH@08JUN2016: I think we need to keep track of the total number of clients ourselves!!!				self.serverSocket.listen(_clients) # no restrictions to the amount of clients we can have				self.output("Listening...",1)				# we need to run a thread taking care of receiving connection requests				self.running=True				self.connectionRequestProcessingThread=threading.Thread(None,self.processConnectionRequests)				self.output("Listening thread created...",1)				self.connectionRequestProcessingThread.start()				# as soon as the thread is alive we can assume to be up and running				if self.connectionRequestProcessingThread.isAlive():					self.running=True					self.output("Listening thread started...",1)				else:					self.outputerror("Failed to start the listening thread.")			except Exception,ex:				self.outputerror("'"+str(ex)+"' in starting the TCP server.")			# if we're supposed to be checking for timeouts do so immediately			if self.timeoutSeconds>0:				threading.Timer(1,self.checkForTimeouts).start()		else:			self.output("TCP server already up and running.",1)		# MDH@27JUN2013: would we want to let the source communicator know something??? (so it will sent it out remotely)		if self.processor:			if self.running:				self.processor("$LOCAL SERVER STARTED ON PORT "+str(self['port'])+".")			else:				self.processor("$FAILED TO START THE LOCAL SERVER ON PORT "+str(self['port'])+"!")	# MDH@09JUL2013: should be considered private!!	def sendTo(self,_tcpClient,_message):		result=False		if _tcpClient.client: # should be a socket on which we can call sendall			# client is available for sending so count			errorcode=_tcpClient.send(_message)			if errorcode:				# if we get a socket shutdown problem (e.errno=110)				# or broken pipe (e.errno=32)				# MDH@02FEB2017: or bad file descriptor (e.errno=9)				# by calling stop() we make tcpClient.client equal to None				# and this will stop the reading loop as well as sending stuff here!!!				if errorcode==110 or errorcode==32 or errorcode==9:					tcpClient.stop()					time.sleep(1) # give it some time to remove the server reference...					self.cleanup()				# we can safely remove the given tcp client				self.outputerror("'"+str(errorcode)+"' sending '"+_message+"'.")			else:				result=True		return result	# MDH 26JUN2013: we might call dispatch to dispatch a message to all local clients	def dispatched(self,_message,_tcpClient=None):		missed=0 # assume success sending to all clients		l=0 # the number of active clients		# MDH@09JUL2013: a specific client can be targeted instead of all of them		if isinstance(_tcpClient,TcpServer.Client):			if self.sendTo(_tcpClient,_message):				l=1			else:				missed=1		else: # to all clients			# MDH@04JUL2013: remove any client not running anymore			#                this is 'automatically' handled by getNumberOfClients()			l=self.getNumberOfClients()			if l>0: # we might have clients to inform...				for tcpClient in self.tcpClients.values():					if self.sendTo(tcpClient,_message):						l+=1					else:						missed+=1		# inform how many we missed (if any)		return (l,missed)	def stop(self):		# we can stop listening by 'killing' the thread (reference)		if self.running:			self.connectionRequestProcessingThread=None			# I think we also need to do something to the serverSocket otherwise it'll keep listening			self.serverSocket.shutdown(socket.SHUT_RDWR)			self.output("TCP server socket shutting down.",1)			time.sleep(0.001)			self.serverSocket.close()			self.output("TCP server socket closing.",1)			# give it some time to actually stop			while self.running:				time.sleep(0.001)			self.output("TCP server now stopped running.",1)		else:			self.outputwarning("Already stopped!")		l=len(self.tcpClients)		if l>0:			self.output("Number of clients to stop: "+str(l)+".",1)			# can we kill all the clients?			for tcpClient in self.tcpClients.values():				tcpClient.stop()			self.tcpClients.clear()		else:			self.output("No clients to stop.",1)	def isRunning(self):		return self.running	# MDH@08AUG2013: replacing _clientAddr (which would be a (host,port) tuple) with _clientHostAddr (just the host part)	# MDH@09JUL2013: a separate method to remove a specific client (called twice)	def removeClient(self,_clientHostAddr,_tcpClient):		del self.tcpClients[_clientHostAddr]		# we're calling clientRemovedCallback passing it the client removed		if hasattr(self.clientRemovedCallback,'__call__'):			self.clientRemovedCallback(_tcpClient)		self.output("Client at host "+str(_clientHostAddr)+" removed!",1)	# MDH@05JUL2013: can be asked for the total number of registered clients	#                which also deals with removing clients no longer active	def getNumberOfClients(self):		# remove any client that is currently no longer running for one reason or another		for (clientHostAddr,clientHostPort),tcpClient in self.tcpClients.items():			# if the server was Noned, we can remove it from the list of active clients...			if tcpClient.server is None:				self.removeClient((clientHostAddr,clientHostPort),tcpClient)		return len(self.tcpClients)	def checkForPushTimeouts(self):		# not all clients need to have a push contract		for tcpClient in self.tcpClients.values():			tcpClient.checkForPushTimeout()	def checkForTimeouts(self,_timeoutSeconds):		# when we're done we're done		if not self.running:			return		# use the given parameter if it is an integer		if isinstance(_timeoutSeconds,int):			secondsToTimeout=_timeoutSeconds		else:			secondsToTimeout=self.timeoutSeconds		# if not positive get out		if secondsToTimeout<1:			return		## print "Checking timeouts"		t=time.time()		# stop any client that I didn't receive some data from since the last time		for clientHostAddr,tcpClient in self.tcpClients.items():			# if the server was Noned, we can remove it from the list of active clients...			if tcpClient.server is None:				self.removeClient(clientHostAddr,tcpClient)			elif tcpClient.dataReceived is None:				tcpClient.stop()				self.output("Stopping client at "+str(clientHostAddr)+": no data received yet!",1)			elif t>tcpClient.dataReceived+secondsToTimeout:				tcpClient.stop()				self.output("Stopping client at "+str(clientHostAddr)+": no data received recently!",1)	# MDH@08JUL2013: we not only check for timeouts but also for push contracts	def tick(self):		try:			# are we checking for timeouts ourselves??? if so, do so			if self.timeoutSeconds>0:				self.checkForTimeouts(self.timeoutSeconds)			# decrease push delay, if they reach zero we should be sending something			self.checkForPushTimeouts()		finally:			threading.Timer(1,self.tick).start()	def startTicking(self):		result=True		if not self.isTicking():			try:				threading.Timer(1,self.tick).start()				self.tickers+=1			except:				result=False				outputerror("Failed to start ticking!")		else:			self.tickers+=1		return result	def stopTicking(self):		# one ticker down		if self.isTicking():			self.tickers-=1	# MDH@04JUL2013: allowing to set a number of seconds to get rid of clients not having received data	def setTimeoutSeconds(self,_timeoutSeconds):		# can we run a timer to deal with that?		if isinstance(_timeoutSeconds,int):			timeoutSecondsNow=self.timeoutSeconds			# we only need to start or stop ticking if we weren't already			if timeoutSecondsNow>0: # I am ticking				self.timeoutSeconds=_timeoutSeconds				if self.timeoutSeconds<=0:					self.stopTicking()			else: # I am NOT ticking				if _timeoutSeconds<=0 or self.startTicking():					self.timeoutSeconds=_timeoutSeconds	def isTicking(self):		return self.tickers>0	def getClientNames(self,_separator=None):		clientNames=[]		# we cannot use self.namedClients here, because getNamedClient will then never get called on any client!!!		for tcpClient in self.tcpClients.values():			clientName=tcpClient.name			if clientName:				if tcpClient.running:					clientNames.append(clientName)				else: # if not currently running, prepend the negative sign					clientNames.append("-"+clientName)		if isinstance(_separator,str):			return _separator.join(clientNames)		return clientNames	def getNamedClient(self,_name):		# MDH@02FEB2017: maybe it'll help NOT to return the first with the given name but the one that is actually running!!!		try:			if self.namedClients is not None and _name in self.namedClients:				client=self.namedClients[_name]				if client.running:					return client				self.output("WARNING: Client with name "+_name+" not running anymore!")			# look for the client with the given name			if self.tcpClients is not None:				self.output("Number of clients to search for the client with name '"+_name+"': "+str(len(self.tcpClients))+".")				for tcpClient in self.tcpClients.values(): # MDH@25JAN2017: essential to use values() here (otherwise accessing (host,port))					if tcpClient.name==_name:						if tcpClient.running:							self.namedClients[_name]=tcpClient # register this client							return tcpClient						self.output("WARNING: Client with name "+_name+" found, but it is not running!") # some warning...			else:				self.output("No clients to search for the client named '"+_name+"'.")		except Exception,ex:			self.outputerror("'"+str(ex)+"' searching for named client '"+str(_name)+"'.")		return None	# constructor	def __init__(self,_port,_processor=None,**_argdict):		dict.__init__(self)		# MDH@17JAN2017: keep track of the clients that have names		self.namedClients=dict()		# initialize the instance fields		# MDH@09JUL2013: ability to install callback functions for adding or removing clients		self.clientAddedCallback=None		self.clientRemovedCallback=None		# ability to assume disconnected when ping not received for a certain number of seconds		self.timeoutSeconds=0		self.tickers=0 # MDH@08JUL2013: not tick sources at the moment		if callable(_processor):			self.processor=_processor		else:			self.processor=None		self.tcpClients=dict()		self.serverSocket=None # the socket being used for listening for connections		self.connectionRequestProcessingThread=None		self.running=False # whether or not currently running		# END initializing instance fields		# start with adding the arguments we can have		self['bind']='' # undefined bind		self['port']=_port # default port to use		self['pingmsg']='ping' # the message postfix to acknowledge!!!		# MDH 04JUL2013: push and pull mode definition		self['pushmsg']='push'		self['pullmsg']='pull'		self['infohandler']=None		if _argdict:			for argkey in _argdict.keys():				if self.has_key(argkey):					self[argkey]=_argdict[argkey]		### "TCP server: "+str(self)+"."	# destructor	def __del__(self):		# # dict.__del__(self)		self.stop()# can also run itself (for testing purposes or on the ConnectPort X2 I guess)def main(argv):	port=65432	pingmsg='ping'	outputFile=None	# we have to build opts ourselves	opts=[]	i=0	while i+1<len(argv):		opts.append((argv[i],argv[i+1]))		i+=2	for opt,arg in opts:		if opt=='-h':			print 'tcpserver.py -o <outputfile> --port <port> --pingmsg <ping message>'			sys.exit()		elif opt in ("-o","--ofile"):			outputFile=arg		elif opt=="--port":			port=int(arg)		elif opt=="--pingmsg":			pingmsg=arg	# ready to try to run the tcpmessenger instance	tcps=TcpServer()	if port:		tcps['port']=port	if pingmsg:		tcps['pingmsg']=pingmsg	# ready to run the server	tcps.start()	# are we redirecting?????	if outputFile:		# redirect all print messages to the given output file		print "Output file is '"+outputFile+"'."		try:			sys.stdout=open(outputFile,'a',0)		except IOError,ex:			print "ERROR '"+str(ex)+"' opening output file."if __name__=="main":	main(sys.argv[1:])